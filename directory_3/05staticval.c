#include <stdio.h>

void incrementFunc(void)
{
    // int count = 0; // 普通のローカル変数だと関数を抜けた時点で破棄される。
    static int count = 0; // static変数。値を保持し続ける
    printf("%d\n", count);
    printf("address = %p\n", &count); // 同じアドレスを指し続ける
    count++; // static変数ならインクリメント値を保持し続ける。ローカル変数だと保持できない
}

int main()
{
    for (int i = 0; i <= 10; i++) {
        incrementFunc(); // ローカル変数のままだと「0」の羅列が続く
    }

    return 0;
}

/*
    incrementFunc()関数は呼び出されるたびに関数内のローカル変数countをインクリメントする
    forループを10回行うので、countは0から増えていき、count = 10になるはずだが、プログラム実行すると
    10回分「0」の値が表示されてしまう。なぜ思ったとおりに動かないのか
    
    なぜなら変数countはローカル変数だからである。ローカル変数は関数の呼び出しごとに初期化され、関数を抜けると破棄される
    よってforループで呼び出されるたびに

    1.変数count初期化
    2.printf()関数で「0」と表示される
    3.インクリメント
    4.破棄
    を繰り返していることになる。これでは値が保持されないので10回ループしても「0」しか表示されないのは
    当たり前である

    こういう場合は「static」を付ける
    static int count = 0;
    「static」を付けた変数はプログラム実行時から、終了時までずっと存在し続ける。初期化は1回だけ
    そのためincrementFunc()関数を抜けてもメモリのどこかに値を保持し続けている
    main()関数終了時に初めて破棄される

    ローカル変数は関数呼び出し時に初期化され、関数終了時に破棄される。また初期化しない場合値は不定
    int count; のように記述して、値を与えないままコンパイルすると警告が出る(ただし、なんだかんだコンパイルできる)
    printf()関数などで使おうとすると「22289」のように想定していない意味の分からない数値が入っているので注意する。問題が
    発生しないように初期化して使う。

    static変数はプログラム実行時から終了時まで存在する。終了時に初めて破棄される。
    またstatic int count; のように初期値を与えずに宣言もできるが、暗黙のうちに「0」が初期値で与えられる。
    と言っても問題が起こらないように値を与えて初期化したほうが良い。
    関数を抜けても値を保持し続けるし、変数のあるアドレスも不変。
*/