#include <stdio.h>

#define GREETING "HELLO WORLD!" // コンパイル前にマクロ名の部分が文字列に置き換わる
#define SUB(a, b) ((a) - (b)) // マクロで関数も宣言できる
#define SIZE 10

int main()
{
    int arr[SIZE];
    printf("arr size = %d\n", sizeof(arr)); // 40Byteになっている
    printf("%s\n", GREETING);

    #ifdef GREETING // マクロが宣言されていれば#ifdefブロックに入る
        puts("MACRO GREETING is declared.");
    #else
        puts("MACRO GREETING is not declared.");
    #endif

    #if 0 // 1 = 真. 0 = 偽.  なにか試したい時に使える
        puts("デバッグに使える");
    #endif

    #define GREETING "Hello C11" // マクロにはスコープが存在しない。宣言した行の下からファイル最終部までに影響するので注意
    printf("%s\n", GREETING);
    
    printf("%d\n", SUB(10, -1)); // ((10) - (-1))に置き換わる。

    // 組み込みマクロ
    printf("LINE = %d\n", __LINE__); // 24
    printf("FILE = %s\n", __FILE__); // preprocessor.c
    printf("DATE = %s\n", __DATE__); // コンパイルした時の月 日 年
    printf("TIME = %s\n", __TIME__); // コンパイルした時の時 分 秒

    return 0;
}

/*
    プリプロセッサ時にコンパイラに対して命令を送ることができる
    ファイル先頭で#include <stdio.h>
    等してヘッダファイルをインクルードしているのも、コンパイラに対して命令を出しているから
    コンパイル前に、プログラム実行に必要な関数を使うために必要なヘッダファイルを展開するように命令を出している
    #include命令の他にマクロ置換というものを使うことができる
    これは「マクロ名」「文字列」の順に定義する。プログラム中にマクロ名を記述すると、コンパイル前のプリプロセス時に
    文字列に置き換えられる
    例えば #define SIZE 10
    と定義して、int arr[SIZE];
    とすると、コンパイル前に「int arr[10];」
    に置き換わる。
    マクロを使えば、仮にプログラムの記述を書き換える場合でもマクロ側を変更すればいちいちプログラム中を探し回って
    変更を加えなくても良い

    「int arr1[10]」「int arr2[10]」「int arr3[10]」 -> これらの配列のサイズを全て「20」にするには
    全てを探して書き換えないといけない

    しかしマクロで「#define SIZE 10」と定義しておきこれを使っていれば(int arr1[SIZE])、これを「#define SIZE 20」にするだけで書き換えられるので
    探す手間も、見つけられない時のミスも防げる

    マクロは便利だが、実態はコンパイル前に定義されたマクロをコンパイラが上から下まで探して文字列に置き換えているだけ
    マクロにはスコープが存在しないので、置き換えたくないスコープ内も無視して置き換えるので注意
    もし #define printf ~~~~
    等としたら、もともとのprintf()関数が自分の定義したマクロで置き換えられてしまう。変数の場合も同様。
    マクロ名は他の変数や関数と衝突しないよう名前にするように気をつける

    マクロには、単に文字列や数字に置き換えるだけでなくマクロ関数というものも存在する
    #define SUB(a, b) ((a) - (b))
    などと定義しておいて呼び出すと
    printf("%d\n", SUB(100, 1)); -> printf("%d\n", ((100) - (1)));
    のように置き換わり関数のように使えるというもの

    ただし、これもマクロなので結局は文字列の置き換えを行っているだけに過ぎない
    例えば単純に「#define SUB(a, b) a - b」と定義して a = 1, b = -1を入れる場合
    コンパイラが気を利かして「1 - (-1)」としてくれるのか、「1 - 1」等と勘違いするかはコンパイルしてみないと分からない
    その後どう処理されるかはコンパイラ次第なので、期待する処理が行われるようにかっこ()を付けたりして
    正しく計算されるよう保護する

    自分で定義したマクロや、ヘッダファイルをインクルードした時に一緒に付いてくるマクロの他に、最初から定義されている
    組み込みマクロも存在する

    マクロ置換はコンパイル前に実行されるので、プログラム実行時に行われる処理に関しては
    全く関与できないことには注意
*/